<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Meta Tags -->
    <title>Jeux - Jo√£o - D√©veloppeur & Cr√©ateur d'Exp√©riences Num√©riques</title>
    <meta name="description" content="Collection de jeux modernes cr√©√©s par Jo√£o - Breakout, Pong, Hexagon, Rhythm Hero avec style cyberpunk.">
    <meta name="keywords" content="Jo√£o, jeux cyberpunk, breakout, pong, hexagon, rhythm hero, rythme, mp3, jeux javascript, jeux en ligne, neon">
    <meta name="author" content="Jo√£o">
    <meta name="robots" content="index, follow">
    <meta name="language" content="fr">
    <link rel="canonical" href="https://oaojfr.github.io/games.html">
    
    <!-- Alternate language versions -->
    <link rel="alternate" href="https://oaojfr.github.io/games.html" hreflang="fr">
    <link rel="alternate" href="https://oaojfr.github.io/games.html" hreflang="en">
    <link rel="alternate" href="https://oaojfr.github.io/games.html" hreflang="pt">
    <link rel="alternate" href="https://oaojfr.github.io/games.html" hreflang="x-default">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://oaojfr.github.io/games.html">
    <meta property="og:title" content="Jeux - Jo√£o - D√©veloppeur & Cr√©ateur d'Exp√©riences Num√©riques">
    <meta property="og:description" content="Collection de jeux modernes cr√©√©s par Jo√£o - Breakout, Pong, Hexagon, Rhythm Hero avec style cyberpunk.">
    <meta property="og:image" content="https://oaojfr.github.io/preview.jpg">
    <meta property="og:site_name" content="Jo√£o Portfolio">
    <meta property="og:locale" content="fr_FR">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://oaojfr.github.io/games.html">
    <meta property="twitter:title" content="Jeux - Jo√£o - D√©veloppeur & Cr√©ateur d'Exp√©riences Num√©riques">
    <meta property="twitter:description" content="Collection de jeux modernes cr√©√©s par Jo√£o - Breakout, Pong, Hexagon, Rhythm Hero avec style cyberpunk.">
    <meta property="twitter:image" content="https://oaojfr.github.io/preview.jpg">
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üéÆ</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üéÆ</text></svg>">
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    // Game previews are now lightweight static SVGs; keep API for future use
    function initGamePreviews() { /* no-op (static previews) */ }
                    // Ligne centrale avec effet n√©on
                    pongCtx.strokeStyle = '#00ffff';
                    pongCtx.lineWidth = 2;
                    pongCtx.setLineDash([10, 10]);
                    pongCtx.beginPath();
                    pongCtx.moveTo(200, 0);
                    pongCtx.lineTo(200, 225);
                    pongCtx.stroke();
                    pongCtx.setLineDash([]);
                    
                    // Ombre n√©on pour la ligne centrale
                    pongCtx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                    pongCtx.lineWidth = 6;
                    pongCtx.setLineDash([10, 10]);
                    pongCtx.beginPath();
                    pongCtx.moveTo(200, 0);
                    pongCtx.lineTo(200, 225);
                    pongCtx.stroke();
                    pongCtx.setLineDash([]);
                    
                    // Paddle gauche avec effet n√©on
                    pongCtx.fillStyle = '#ff6600';
                    pongCtx.fillRect(20, paddle1Y, 8, 45);
                    pongCtx.shadowColor = '#ff6600';
                    pongCtx.shadowBlur = 10;
                    pongCtx.fillRect(20, paddle1Y, 8, 45);
                    pongCtx.shadowBlur = 0;
                    
                    // Paddle droite avec effet n√©on
                    pongCtx.fillStyle = '#9933ff';
                    pongCtx.fillRect(372, paddle2Y, 8, 45);
                    pongCtx.shadowColor = '#9933ff';
                    pongCtx.shadowBlur = 10;
                    pongCtx.fillRect(372, paddle2Y, 8, 45);
                    pongCtx.shadowBlur = 0;
                    
                    // Balle avec trail n√©on
                    glowIntensity = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
                    
                    // Trail de la balle
                    for (let i = 1; i <= 5; i++) {
                        const trailX = ballX - ballVelX * i * 2;
                        const trailY = ballY - ballVelY * i * 2;
                        const opacity = (6 - i) / 6 * 0.3;
                        
                        pongCtx.fillStyle = `rgba(255, 255, 0, ${opacity})`;
                        pongCtx.fillRect(trailX - 4, trailY - 4, 8, 8);
                    }
                    
                    // Balle principale
                    pongCtx.fillStyle = '#ffff00';
                    pongCtx.fillRect(ballX - 6, ballY - 6, 12, 12);
                    
                    // Effet de lueur sur la balle
                    const ballGlow = pongCtx.createRadialGradient(ballX, ballY, 0, ballX, ballY, 15);
                    ballGlow.addColorStop(0, `rgba(255, 255, 0, ${0.6 + glowIntensity * 0.4})`);
                    ballGlow.addColorStop(1, 'rgba(255, 255, 0, 0)');
                    pongCtx.fillStyle = ballGlow;
                    pongCtx.fillRect(ballX - 15, ballY - 15, 30, 30);
                    
                    // Animation
                    ballX += ballVelX;
                    ballY += ballVelY;
                    
                    // Rebonds sur les murs
                    if (ballY <= 6 || ballY >= 219) ballVelY = -ballVelY;
                    if (ballX <= 0 || ballX >= 400) {
                        ballVelX = -ballVelX;
                        ballX = 200;
                        ballY = 112;
                    }
                    
                    // IA simple pour les paddles
                    paddle1Y += (ballY - paddle1Y - 22.5) * 0.03;
                    paddle2Y += (ballY - paddle2Y - 22.5) * 0.025;
                    
                    // Limites des paddles
                    paddle1Y = Math.max(0, Math.min(180, paddle1Y));
                    paddle2Y = Math.max(0, Math.min(180, paddle2Y));
                }

                const pongLoop = makePreviewLoop(drawPong, preferredFPS);
                pongLoop.start();
                previewLoops.push(pongLoop);
                new IntersectionObserver((entries) => {
                    entries.forEach(e => e.isIntersecting ? pongLoop.start() : pongLoop.stop());
                }, { threshold: 0.1 }).observe(pongCanvas);
            }

            // Hexagon Preview - Reproduction PARFAITE de Super Hexagon
            const hexagonCanvas = document.getElementById('hexagonPreview');
            if (hexagonCanvas) {
                const hexagonCtx = hexagonCanvas.getContext('2d');
                hexagonCanvas.width = 400;
                hexagonCanvas.height = 225;
                
                // Configuration fid√®le au vrai jeu
                const CENTER_X = 200;
                const CENTER_Y = 112;
                const HEX_RADIUS = 30; // Hexagone central plus visible
                const PLAYER_RADIUS = HEX_RADIUS + 12; // Joueur tr√®s proche du centre
                
                let gameTime = 0;
                let worldRotation = 0;
                let colorShift = 0;
                let spawnTimer = 0;
                
                // Player avec mouvement fluide et positions discr√®tes
                let player = {
                    position: 0, // Position discr√®te (0-5)
                    targetPosition: 0,
                    angle: 0,
                    moveSpeed: 0.12,
                    size: 5
                };
                
                let walls = [];
                let particles = [];
                
                // Patterns EXACTEMENT comme Super Hexagon
                const wallPatterns = [
                    [1, 1, 1, 1, 0, 1], // Une ouverture
                    [1, 1, 0, 1, 1, 1], // Une ouverture d√©cal√©e
                    [0, 1, 1, 1, 1, 1], // Une ouverture au d√©but
                    [1, 0, 1, 1, 1, 1], // Une ouverture d√©cal√©e
                    [1, 1, 0, 0, 1, 1], // Deux ouvertures cons√©cutives
                    [0, 1, 1, 0, 1, 1], // Deux ouvertures s√©par√©es
                    [1, 0, 1, 0, 1, 1], // Motif alternant
                    [0, 0, 1, 1, 1, 1], // Deux ouvertures au d√©but
                    [1, 0, 1, 0, 1, 0], // Altern√© parfait
                    [0, 1, 0, 1, 1, 1]  // Complexe
                ];
                
                // Couleurs dynamiques comme l'original
                const hexagonColors = ['#00ffff', '#ff4444', '#ffff00', '#ff00ff', '#00ff00'];
                
                function spawnWallPattern() {
                    const pattern = wallPatterns[Math.floor(Math.random() * wallPatterns.length)];
                    const spawnDistance = 150;
                    
                    for (let segment = 0; segment < 6; segment++) {
                        if (pattern[segment] === 1) { // 1 = mur bloqu√©
                            walls.push({
                                segment: segment,
                                distance: spawnDistance,
                                width: 20, // √âpaisseur du mur
                                speed: 1.5, // Vitesse vers le centre
                                color: hexagonColors[Math.floor(Math.random() * hexagonColors.length)]
                            });
                        }
                    }
                }
                
                function updatePlayer() {
                    // Mouvement automatique fluide pour la d√©mo
                    if (Math.random() < 0.015) { // Change direction parfois
                        const direction = Math.random() > 0.5 ? 1 : -1;
                        player.targetPosition = (player.targetPosition + direction + 6) % 6;
                    }
                    
                    // Interpolation fluide vers la position cible
                    let diff = player.targetPosition - player.position;
                    
                    // Ajuster pour le chemin le plus court autour du cercle
                    if (diff > 3) diff -= 6;
                    if (diff < -3) diff += 6;
                    
                    player.position += diff * player.moveSpeed;
                    
                    // Normaliser la position
                    if (player.position < 0) player.position += 6;
                    if (player.position >= 6) player.position -= 6;
                    
                    // Calculer l'angle pour le rendu
                    player.angle = (player.position * Math.PI) / 3;
                }
                
                function updateWalls() {
                    for (let i = walls.length - 1; i >= 0; i--) {
                        const wall = walls[i];
                        wall.distance -= wall.speed;
                        
                        // Supprimer les murs qui atteignent le centre
                        if (wall.distance <= HEX_RADIUS) {
                            walls.splice(i, 1);
                        }
                    }
                    
                    // Spawn p√©riodique de nouveaux patterns
                    spawnTimer++;
                    if (spawnTimer >= 120) { // Tous les 2 secondes
                        spawnTimer = 0;
                        spawnWallPattern();
                    }
                }
                
                function drawBackground() {
                    // Background hypnotique avec d√©grad√© radial rotatif
                    const bgGradient = hexagonCtx.createRadialGradient(CENTER_X, CENTER_Y, 0, CENTER_X, CENTER_Y, 200);
                    const hue1 = (colorShift * 0.7) % 360;
                    const hue2 = (colorShift * 0.3 + 120) % 360;
                    
                    bgGradient.addColorStop(0, `hsl(${hue1}, 40%, 8%)`);
                    bgGradient.addColorStop(0.5, `hsl(${hue2}, 50%, 4%)`);
                    bgGradient.addColorStop(1, '#000012');
                    
                    hexagonCtx.fillStyle = bgGradient;
                    hexagonCtx.fillRect(0, 0, 400, 225);
                    
                    // Effet de lignes rayonnantes tournantes
                    hexagonCtx.save();
                    hexagonCtx.translate(CENTER_X, CENTER_Y);
                    hexagonCtx.rotate(worldRotation * 0.3);
                    
                    for (let i = 0; i < 12; i++) {
                        const angle = (i * Math.PI) / 6;
                        const alpha = 0.03 + Math.sin(gameTime * 0.1 + i) * 0.02;
                        
                        hexagonCtx.strokeStyle = `hsla(${(colorShift + i * 30) % 360}, 60%, 50%, ${alpha})`;
                        hexagonCtx.lineWidth = 1;
                        hexagonCtx.beginPath();
                        hexagonCtx.moveTo(0, 0);
                        hexagonCtx.lineTo(Math.cos(angle) * 300, Math.sin(angle) * 300);
                        hexagonCtx.stroke();
                    }
                    
                    hexagonCtx.restore();
                }
                
                function drawHexagonalWalls() {
                    hexagonCtx.save();
                    hexagonCtx.translate(CENTER_X, CENTER_Y);
                    hexagonCtx.rotate(worldRotation);
                    
                    walls.forEach(wall => {
                        const segmentAngle = (wall.segment * Math.PI) / 3;
                        const angleStart = segmentAngle - Math.PI / 6;
                        const angleEnd = segmentAngle + Math.PI / 6;
                        
                        // Points du segment hexagonal externe
                        const outerStart = {
                            x: Math.cos(angleStart) * wall.distance,
                            y: Math.sin(angleStart) * wall.distance
                        };
                        const outerEnd = {
                            x: Math.cos(angleEnd) * wall.distance,
                            y: Math.sin(angleEnd) * wall.distance
                        };
                        
                        // Points du segment hexagonal interne
                        const innerDistance = wall.distance - wall.width;
                        const innerStart = {
                            x: Math.cos(angleStart) * innerDistance,
                            y: Math.sin(angleStart) * innerDistance
                        };
                        const innerEnd = {
                            x: Math.cos(angleEnd) * innerDistance,
                            y: Math.sin(angleEnd) * innerDistance
                        };
                        
                        // Dessiner le mur trap√©zo√Ødal
                        hexagonCtx.fillStyle = wall.color;
                        hexagonCtx.shadowColor = wall.color;
                        hexagonCtx.shadowBlur = 8;
                        
                        hexagonCtx.beginPath();
                        hexagonCtx.moveTo(outerStart.x, outerStart.y);
                        hexagonCtx.lineTo(outerEnd.x, outerEnd.y);
                        hexagonCtx.lineTo(innerEnd.x, innerEnd.y);
                        hexagonCtx.lineTo(innerStart.x, innerStart.y);
                        hexagonCtx.closePath();
                        hexagonCtx.fill();
                        
                        hexagonCtx.shadowBlur = 0;
                    });
                    
                    hexagonCtx.restore();
                }
                
                function drawCentralHexagon() {
                    hexagonCtx.save();
                    hexagonCtx.translate(CENTER_X, CENTER_Y);
                    hexagonCtx.rotate(worldRotation);
                    
                    // Pulsation hypnotique
                    const pulse = 1 + Math.sin(gameTime * 0.15) * 0.15;
                    const currentRadius = HEX_RADIUS * pulse;
                    const mainHue = (colorShift * 1.5) % 360;
                    
                    // Hexagone central lumineux
                    hexagonCtx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI) / 3;
                        const x = Math.cos(angle) * currentRadius;
                        const y = Math.sin(angle) * currentRadius;
                        if (i === 0) hexagonCtx.moveTo(x, y);
                        else hexagonCtx.lineTo(x, y);
                    }
                    hexagonCtx.closePath();
                    
                    hexagonCtx.strokeStyle = `hsl(${mainHue}, 100%, 85%)`;
                    hexagonCtx.lineWidth = 4;
                    hexagonCtx.shadowColor = `hsl(${mainHue}, 100%, 85%)`;
                    hexagonCtx.shadowBlur = 20;
                    hexagonCtx.stroke();
                    hexagonCtx.shadowBlur = 0;
                    
                    // Anneaux concentriques pour l'effet tunnel
                    for (let ring = 1; ring <= 3; ring++) {
                        const ringRadius = currentRadius + ring * 25;
                        const ringHue = (mainHue + ring * 80) % 360;
                        const alpha = 0.4 - ring * 0.1;
                        
                        hexagonCtx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            const x = Math.cos(angle) * ringRadius;
                            const y = Math.sin(angle) * ringRadius;
                            if (i === 0) hexagonCtx.moveTo(x, y);
                            else hexagonCtx.lineTo(x, y);
                        }
                        hexagonCtx.closePath();
                        
                        hexagonCtx.strokeStyle = `hsla(${ringHue}, 80%, 60%, ${alpha})`;
                        hexagonCtx.lineWidth = 2;
                        hexagonCtx.stroke();
                    }
                    
                    hexagonCtx.restore();
                }
                
                function drawPlayer() {
                    hexagonCtx.save();
                    hexagonCtx.translate(CENTER_X, CENTER_Y);
                    hexagonCtx.rotate(worldRotation);
                    
                    // Position du joueur autour de l'hexagone
                    const playerX = Math.cos(player.angle) * PLAYER_RADIUS;
                    const playerY = Math.sin(player.angle) * PLAYER_RADIUS;
                    
                    hexagonCtx.save();
                    hexagonCtx.translate(playerX, playerY);
                    hexagonCtx.rotate(player.angle + Math.PI / 2); // Orienter vers le centre
                    
                    // Triangle blanc lumineux
                    hexagonCtx.fillStyle = '#ffffff';
                    hexagonCtx.shadowColor = '#ffffff';
                    hexagonCtx.shadowBlur = 15;
                    
                    hexagonCtx.beginPath();
                    hexagonCtx.moveTo(0, -player.size);
                    hexagonCtx.lineTo(-player.size * 0.7, player.size);
                    hexagonCtx.lineTo(player.size * 0.7, player.size);
                    hexagonCtx.closePath();
                    hexagonCtx.fill();
                    
                    hexagonCtx.shadowBlur = 0;
                    hexagonCtx.restore();
                    hexagonCtx.restore();
                }
                
                function gameLoop() {
                    gameTime += 1;
                    worldRotation += 0.018; // Rotation constante et hypnotique
                    colorShift += 1.2;
                    
                    updatePlayer();
                    updateWalls();
                    
                    // Rendu
                    drawBackground();
                    drawHexagonalWalls();
                    drawCentralHexagon();
                    drawPlayer();
                }
                
                // Spawn initial de patterns
                spawnWallPattern();
                setTimeout(() => spawnWallPattern(), 1000);
                
                const hexagonLoop = makePreviewLoop(gameLoop, preferredFPS);
                hexagonLoop.start();
                previewLoops.push(hexagonLoop);
                new IntersectionObserver((entries) => {
                    entries.forEach(e => e.isIntersecting ? hexagonLoop.start() : hexagonLoop.stop());
                }, { threshold: 0.1 }).observe(hexagonCanvas);
            }

            // Rhythm Preview - Simulation du vrai jeu avec notes qui tombent et lanes
            const rhythmCanvas = document.getElementById('rhythmPreview');
            if (rhythmCanvas) {
                const rhythmCtx = rhythmCanvas.getContext('2d');
                rhythmCanvas.width = 400;
                rhythmCanvas.height = 225;
                
                let notes = [];
                let time = 0;
                let beatTime = 0;
                let lanes = [{ active: false }, { active: false }, { active: false }, { active: false }];
                let hitEffects = [];
                let feverMode = false;
                let feverTime = 0;
                
                const laneColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4']; // F, G, J, K
                const laneWidth = 80;
                const hitZoneY = 180;
                
                // Generate realistic falling notes
                function spawnNote() {
                    if (Math.random() < 0.3) { // 30% chance per frame
                        const lane = Math.floor(Math.random() * 4);
                        const isLongNote = Math.random() < 0.2; // 20% chance for long notes
                        
                        notes.push({
                            lane: lane,
                            x: 60 + lane * laneWidth,
                            y: -20,
                            speed: 3,
                            color: laneColors[lane],
                            isLong: isLongNote,
                            length: isLongNote ? 40 + Math.random() * 60 : 0,
                            hit: false,
                            spawned: true
                        });
                    }
                }
                
                function addHitEffect(x, y, color) {
                    hitEffects.push({
                        x: x, y: y,
                        particles: Array.from({length: 8}, () => ({
                            dx: (Math.random() - 0.5) * 8,
                            dy: (Math.random() - 0.5) * 8 - 2,
                            life: 20,
                            size: Math.random() * 4 + 2
                        })),
                        color: color,
                        time: 0
                    });
                }
                
                function drawRhythm() {
                    time += 1;
                    beatTime += 0.1;
                    
                    // Dynamic background with beat reaction
                    const beatPulse = Math.sin(beatTime * 2) * 0.3 + 0.7;
                    const bgGradient = rhythmCtx.createLinearGradient(0, 0, 0, 225);
                    
                    if (feverMode) {
                        bgGradient.addColorStop(0, `rgba(50, 0, 50, ${beatPulse})`);
                        bgGradient.addColorStop(0.5, `rgba(80, 0, 40, ${beatPulse * 0.8})`);
                        bgGradient.addColorStop(1, '#000000');
                        feverTime--;
                        if (feverTime <= 0) feverMode = false;
                    } else {
                        bgGradient.addColorStop(0, `rgba(10, 10, 15, ${beatPulse})`);
                        bgGradient.addColorStop(0.5, `rgba(5, 15, 25, ${beatPulse * 0.8})`);
                        bgGradient.addColorStop(1, '#000000');
                    }
                    
                    rhythmCtx.fillStyle = bgGradient;
                    rhythmCtx.fillRect(0, 0, 400, 225);
                    
                    // Draw lanes with beat-reactive glow
                    for (let i = 0; i < 4; i++) {
                        const x = 60 + i * laneWidth;
                        const laneGlow = lanes[i].active ? 1 : 0.3;
                        
                        // Lane background
                        rhythmCtx.fillStyle = `rgba(${laneColors[i].slice(1, 3)}, ${laneColors[i].slice(3, 5)}, ${laneColors[i].slice(5, 7)}, 0.1)`;
                        rhythmCtx.fillRect(x - laneWidth/2, 0, laneWidth, 225);
                        
                        // Lane borders
                        rhythmCtx.strokeStyle = `${laneColors[i]}${Math.floor(laneGlow * 255).toString(16).padStart(2, '0')}`;
                        rhythmCtx.lineWidth = 2;
                        rhythmCtx.beginPath();
                        rhythmCtx.moveTo(x - laneWidth/2, 0);
                        rhythmCtx.lineTo(x - laneWidth/2, 225);
                        rhythmCtx.moveTo(x + laneWidth/2, 0);
                        rhythmCtx.lineTo(x + laneWidth/2, 225);
                        rhythmCtx.stroke();
                        
                        lanes[i].active = false;
                    }
                    
                    // Hit zone (where notes should be hit)
                    rhythmCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    rhythmCtx.fillRect(0, hitZoneY - 15, 400, 30);
                    
                    // Lane hit zones
                    for (let i = 0; i < 4; i++) {
                        const x = 60 + i * laneWidth;
                        rhythmCtx.strokeStyle = laneColors[i];
                        rhythmCtx.lineWidth = 3;
                        rhythmCtx.strokeRect(x - laneWidth/2 + 5, hitZoneY - 15, laneWidth - 10, 30);
                    }
                    
                    // Spawn notes periodically
                    if (time % 20 === 0) spawnNote();
                    
                    // Draw and update notes
                    notes.forEach((note, index) => {
                        note.y += note.speed;
                        
                        // Draw long note body
                        if (note.isLong) {
                            rhythmCtx.fillStyle = note.color + '88';
                            rhythmCtx.fillRect(note.x - 25, note.y, 50, note.length);
                            
                            // Long note borders
                            rhythmCtx.strokeStyle = note.color;
                            rhythmCtx.lineWidth = 2;
                            rhythmCtx.strokeRect(note.x - 25, note.y, 50, note.length);
                        }
                        
                        // Draw note head
                        rhythmCtx.fillStyle = note.color;
                        rhythmCtx.shadowColor = note.color;
                        rhythmCtx.shadowBlur = 10;
                        rhythmCtx.fillRect(note.x - 25, note.y - 10, 50, 20);
                        rhythmCtx.shadowBlur = 0;
                        
                        // Note glow effect
                        rhythmCtx.strokeStyle = '#ffffff';
                        rhythmCtx.lineWidth = 1;
                        rhythmCtx.strokeRect(note.x - 25, note.y - 10, 50, 20);
                        
                        // Auto-hit simulation near hit zone
                        if (!note.hit && note.y >= hitZoneY - 20 && note.y <= hitZoneY + 20) {
                            note.hit = true;
                            lanes[note.lane].active = true;
                            addHitEffect(note.x, hitZoneY, note.color);
                            
                            // Random fever mode activation
                            if (Math.random() < 0.1) {
                                feverMode = true;
                                feverTime = 100;
                            }
                        }
                        
                        // Remove notes that are off-screen
                        if (note.y > 250) {
                            notes.splice(index, 1);
                        }
                    });
                    
                    // Draw hit effects
                    hitEffects.forEach((effect, index) => {
                        effect.time++;
                        
                        effect.particles.forEach(particle => {
                            particle.x = effect.x + particle.dx * effect.time;
                            particle.y = effect.y + particle.dy * effect.time;
                            particle.life--;
                            
                            if (particle.life > 0) {
                                const alpha = particle.life / 20;
                                rhythmCtx.fillStyle = effect.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                                rhythmCtx.beginPath();
                                rhythmCtx.arc(particle.x, particle.y, particle.size * alpha, 0, Math.PI * 2);
                                rhythmCtx.fill();
                            }
                        });
                        
                        if (effect.time > 20) {
                            hitEffects.splice(index, 1);
                        }
                    });
                    
                    // Fever mode indicator
                    if (feverMode) {
                        rhythmCtx.fillStyle = '#ff6b6b';
                        rhythmCtx.font = 'bold 16px Arial';
                        rhythmCtx.fillText('FEVER MODE!', 150, 30);
                        
                        // Screen border glow
                        rhythmCtx.strokeStyle = '#ff6b6b';
                        rhythmCtx.lineWidth = 5;
                        rhythmCtx.strokeRect(2, 2, 396, 221);
                    }
                    
                    // Key indicators (F G J K)
                    const keys = ['F', 'G', 'J', 'K'];
                    for (let i = 0; i < 4; i++) {
                        const x = 60 + i * laneWidth;
                        const alpha = lanes[i].active ? 1 : 0.5;
                        
                        rhythmCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        rhythmCtx.font = 'bold 20px Arial';
                        rhythmCtx.textAlign = 'center';
                        rhythmCtx.fillText(keys[i], x, 210);
                    }
                }

                const rhythmLoop = makePreviewLoop(drawRhythm, preferredFPS);
                rhythmLoop.start();
                previewLoops.push(rhythmLoop);
                new IntersectionObserver((entries) => {
                    entries.forEach(e => e.isIntersecting ? rhythmLoop.start() : rhythmLoop.stop());
                }, { threshold: 0.1 }).observe(rhythmCanvas);
            }

            // Pause all previews when tab is hidden to save resources
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) previewLoops.forEach(l => l.stop());
                else previewLoops.forEach(l => l.start());
            });
        }

        let currentTheme = 'light';

        // Theme switching
        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.getElementById('theme-icon');
            
            if (currentTheme === 'light') {
                body.setAttribute('data-theme', 'dark');
                themeIcon.className = 'bi bi-sun-fill';
                currentTheme = 'dark';
            } else {
                body.removeAttribute('data-theme');
                themeIcon.className = 'bi bi-moon-fill';
                currentTheme = 'light';
            }
            
            localStorage.setItem('preferred-theme', currentTheme);
        }

        // Change language
    </script>
</body>
</html>
