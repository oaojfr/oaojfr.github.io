<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Meta Tags -->
    <title>Jeux - João - Développeur & Créateur d'Expériences Numériques</title>
    <meta name="description" content="Collection de jeux modernes créés par João - Breakout, Pong, Hexagon, Rhythm Hero avec style cyberpunk.">
    <meta name="keywords" content="João, jeux cyberpunk, breakout, pong, hexagon, rhythm hero, rythme, mp3, jeux javascript, jeux en ligne, neon">
    <meta name="author" content="João">
    <meta name="robots" content="index, follow">
    <meta name="language" content="fr">
    <link rel="canonical" href="https://oaojfr.github.io/games.html">
    
    <!-- Alternate language versions -->
    <link rel="alternate" href="https://oaojfr.github.io/games.html" hreflang="fr">
    <link rel="alternate" href="https://oaojfr.github.io/games.html" hreflang="en">
    <link rel="alternate" href="https://oaojfr.github.io/games.html" hreflang="pt">
    <link rel="alternate" href="https://oaojfr.github.io/games.html" hreflang="x-default">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://oaojfr.github.io/games.html">
    <meta property="og:title" content="Jeux - João - Développeur & Créateur d'Expériences Numériques">
    <meta property="og:description" content="Collection de jeux modernes créés par João - Breakout, Pong, Hexagon, Rhythm Hero avec style cyberpunk.">
    <meta property="og:image" content="https://oaojfr.github.io/preview.jpg">
    <meta property="og:site_name" content="João Portfolio">
    <meta property="og:locale" content="fr_FR">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://oaojfr.github.io/games.html">
    <meta property="twitter:title" content="Jeux - João - Développeur & Créateur d'Expériences Numériques">
    <meta property="twitter:description" content="Collection de jeux modernes créés par João - Breakout, Pong, Hexagon, Rhythm Hero avec style cyberpunk.">
    <meta property="twitter:image" content="https://oaojfr.github.io/preview.jpg">
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🎮</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🎮</text></svg>">
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --accent-color: #ff6b6b;
            --text-color: #333;
            --bg-color: #fff;
            --bg-secondary: #f8f9fa;
            --card-bg: #fff;
            --navbar-bg: rgba(102, 126, 234, 0.1);
            --navbar-bg-scroll: rgba(102, 126, 234, 0.2);
            --footer-bg: #2c3e50;
        }

        [data-theme="dark"] {
            --text-color: #e0e0e0;
            --bg-color: #121212;
            --bg-secondary: #1e1e1e;
            --card-bg: #2d2d2d;
            --navbar-bg: rgba(45, 45, 45, 0.9);
            --navbar-bg-scroll: rgba(45, 45, 45, 0.95);
            --footer-bg: #1a1a1a;
        }

        body {
            font-family: 'Poppins', sans-serif;
            line-height: 1.6;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            flex: 1;
        }

        .navbar {
            background-color: var(--navbar-bg);
            backdrop-filter: blur(10px);
            transition: background-color 0.3s ease;
        }

        .navbar.scrolled {
            background-color: var(--navbar-bg-scroll);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .navbar-brand {
            font-weight: 700;
            font-size: 1.5rem;
            color: white !important;
        }

        .nav-link {
            font-weight: 500;
            color: var(--text-color) !important;
            transition: color 0.3s ease;
        }

        .nav-link:hover,
        .nav-link.active {
            color: var(--primary-color) !important;
        }

        .dropdown-menu {
            background-color: var(--card-bg);
            border: 1px solid rgba(102, 126, 234, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .dropdown-item {
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        .dropdown-item:hover {
            background-color: var(--bg-secondary);
            color: var(--primary-color);
        }

        [data-theme="dark"] .dropdown-menu {
            background-color: var(--card-bg);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .section-title {
            font-size: 2.5rem;
            font-weight: 600;
            margin-bottom: 3rem;
            text-align: center;
            position: relative;
        }
        
        .section-title::after {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 3px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 3px;
        }

        .game-card {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            height: 100%;
            display: flex;
            flex-direction: column;
            border: 2px solid transparent;
            position: relative;
        }

        .game-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 15px;
            padding: 2px;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color), var(--accent-color));
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .game-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
        }

        .game-card:hover::before {
            opacity: 1;
        }

        .game-preview {
            aspect-ratio: 16/9;
            overflow: hidden;
            position: relative;
            background: linear-gradient(45deg, #1a1a1a, #2d2d2d);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Scanlines effect */
        .game-preview::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 0, 0.03) 2px,
                rgba(0, 255, 0, 0.03) 4px
            );
            pointer-events: none;
        }

        /* Glow effect */
        .game-preview .glow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            border-radius: 50%;
            filter: blur(20px);
            opacity: 0.3;
            z-index: 1;
            pointer-events: none;
        }

        .game-card-content {
            padding: 1.5rem;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 5;
        }

        .game-card-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-color);
        }

        .game-card-description {
            color: var(--text-color);
            opacity: 0.8;
            margin-bottom: 1rem;
            flex-grow: 1;
        }

        .btn-play {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 50px;
            font-weight: 500;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            align-self: flex-start;
            position: relative;
            z-index: 10;
        }

        .btn-play:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            color: white;
        }

        .footer {
            background-color: var(--footer-bg);
            color: white;
            padding: 3rem 0;
            margin-top: 4rem;
        }

        .footer a {
            color: #fff;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        .footer a:hover {
            opacity: 1;
            text-decoration: none;
        }



        /* Arcade/Retro Styling */
        .arcade-header {
            background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
            padding: 2rem;
            border-radius: 15px;
            margin-bottom: 3rem;
            position: relative;
            overflow: hidden;
        }

        .arcade-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                90deg,
                rgba(0, 255, 255, 0.03),
                rgba(0, 255, 255, 0.03) 2px,
                transparent 2px,
                transparent 4px
            );
        }

        .arcade-title {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            letter-spacing: 2px;
            animation: neonGlow 2s ease-in-out infinite alternate;
        }

        @keyframes neonGlow {
            from {
                text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
            }
            to {
                text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff, 0 0 40px #00ffff;
            }
        }

        .pixel-font {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        /* Theme Toggle Button */
        .theme-toggle {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .theme-toggle:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.1);
        }

        [data-theme="dark"] .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 768px) {
            .section-title {
                font-size: 2rem;
            }
            
            .arcade-title {
                font-size: 1.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="main-content">
    <!-- Navigation Menu -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top" style="background: var(--navbar-bg); border-bottom: 1px solid rgba(102, 126, 234, 0.2);">
        <div class="container">
            <a class="navbar-brand fw-bold" href="index.html" data-translate="nav.brand">João</a>
            <div class="d-flex align-items-center order-lg-2">
                <!-- Theme Toggle -->
                <button class="theme-toggle me-3" onclick="toggleTheme()">
                    <i class="bi bi-moon-fill" id="theme-icon"></i>
                </button>
            </div>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html" data-translate="nav.home">Accueil</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html#about" data-translate="nav.about">À propos</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html#projects" data-translate="nav.projects">Projets</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="games.html" data-translate="nav.games">Jeux</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="tools.html" data-translate="nav.tools">Outils</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="index.html#contact" data-translate="nav.contact">Contact</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="navbarDropdown">
                            <li><a class="dropdown-item" href="#" onclick="changeLanguage('fr')">Français</a></li>
                            <li><a class="dropdown-item" href="#" onclick="changeLanguage('en')">English</a></li>
                            <li><a class="dropdown-item" href="#" onclick="changeLanguage('pt')">Português</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Games Section Header -->
    <div class="container mt-5 pt-5">
        <div class="arcade-header">
            <h1 class="arcade-title text-center" data-translate="games.title">SALLE DE JEUX</h1>
            <p class="text-center mb-0 text-light" data-translate="games.description">
                DÉCOUVREZ MA COLLECTION DE JEUX RÉTRO CRÉÉS EN JAVASCRIPT
            </p>
        </div>

        <!-- Games Grid -->
        <div class="row g-4">
            <!-- Breakout Game Card -->
            <div class="col-md-6 col-lg-4">
                <div class="game-card">
                    <div class="game-preview">
                        <canvas class="game-canvas" id="breakoutPreview"></canvas>
                        <div class="glow" style="background: radial-gradient(circle, rgba(255,165,0,0.3), transparent);"></div>
                    </div>
                    <div class="game-card-content">
                        <h2 class="game-card-title pixel-font" data-translate="games.breakout.name">🧱 BREAKOUT</h2>
                        <p class="game-card-description" data-translate="games.breakout.description">
                            Cassez toutes les briques avec des power-ups, effets visuels et 8 pistes musicales générées.
                        </p>
                        <a href="games/breakout/index.html" class="btn btn-play" data-translate="games.play">JOUER</a>
                    </div>
                </div>
            </div>

            <!-- Pong Game Card -->
            <div class="col-md-6 col-lg-4">
                <div class="game-card">
                    <div class="game-preview">
                        <canvas class="game-canvas" id="pongPreview"></canvas>
                        <div class="glow" style="background: radial-gradient(circle, rgba(0,255,255,0.3), transparent);"></div>
                    </div>
                    <div class="game-card-content">
                        <h2 class="game-card-title pixel-font" data-translate="games.pong.name">🏓 PONG</h2>
                        <p class="game-card-description" data-translate="games.pong.description">
                            Tennis de table cyberpunk avec IA adaptive, effets néon et 6 pistes d'ambiance électronique.
                        </p>
                        <a href="games/pong/index.html" class="btn btn-play" data-translate="games.play">JOUER</a>
                    </div>
                </div>
            </div>

            <!-- Hexagon Game Card -->
            <div class="col-md-6 col-lg-4">
                <div class="game-card">
                    <div class="game-preview">
                        <canvas class="game-canvas" id="hexagonPreview"></canvas>
                        <div class="glow" style="background: radial-gradient(circle, rgba(255,0,255,0.3), transparent);"></div>
                    </div>
                    <div class="game-card-content">
                        <h2 class="game-card-title pixel-font" data-translate="games.hexagon.name">⬢ HEXAGON</h2>
                        <p class="game-card-description" data-translate="games.hexagon.description">
                            Jeu de réflexes extrême avec 4 niveaux de difficulté, rotation du monde et musique Super Hexagon.
                        </p>
                        <a href="games/hexagon/index.html" class="btn btn-play" data-translate="games.play">JOUER</a>
                    </div>
                </div>
            </div>

            <!-- Rhythm Hero Game Card -->
            <div class="col-md-6 col-lg-4">
                <div class="game-card">
                    <div class="game-preview">
                        <canvas class="game-canvas" id="rhythmPreview"></canvas>
                        <div class="glow" style="background: radial-gradient(circle, rgba(255,107,107,0.3), transparent);"></div>
                    </div>
                    <div class="game-card-content">
                        <h2 class="game-card-title pixel-font" data-translate="games.rhythm.name">🎵 RHYTHM HERO</h2>
                        <p class="game-card-description" data-translate="games.rhythm.description">
                            Analysez vos MP3 et jouez avec détection BPM auto, 4 difficultés, notes longues et fever mode !
                        </p>
                        <a href="games/rhythm/index.html" class="btn btn-play" data-translate="games.play">JOUER</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div>

    <!-- Footer -->
    <footer class="footer mt-auto">
        <div class="container text-center">
            <p data-translate="footer.copyright">© 2025 João. Tous droits réservés. Fait avec <i class="bi bi-heart-fill text-danger"></i> <span data-translate="footer.made">et Bootstrap.</span></p>
        </div>
    </footer>


    
    <!-- Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        window.addEventListener('scroll', function() {
            const navbar = document.querySelector('.navbar');
            if (window.scrollY > 50) {
                navbar.classList.add('scrolled');
            } else {
                navbar.classList.remove('scrolled');
            }
        });

        // Translation functionality
        const translations = {
            fr: {
                'nav.brand': 'João',
                'nav.home': 'Accueil',
                'nav.about': 'À propos',
                'nav.projects': 'Projets',
                'nav.games': 'Jeux',
                'nav.tools': 'Outils',
                'nav.contact': 'Contact',
                'games.title': 'SALLE DE JEUX',
                'games.description': 'DÉCOUVREZ MA COLLECTION DE JEUX RÉTRO CRÉÉS EN JAVASCRIPT',
                'games.breakout.name': '🧱 BREAKOUT',
                'games.breakout.description': 'Cassez toutes les briques avec des power-ups, effets visuels et 8 pistes musicales générées.',
                'games.pong.name': '🏓 PONG',
                'games.pong.description': 'Tennis de table cyberpunk avec IA adaptive, effets néon et 6 pistes d\'ambiance électronique.',
                'games.hexagon.name': '⬢ SUPER HEXAGON',
                'games.hexagon.description': 'Jeu de réflexes extrême avec 4 niveaux de difficulté, rotation du monde et musique Super Hexagon.',
                'games.rhythm.name': '🎵 RHYTHM HERO',
                'games.rhythm.description': 'Analysez vos MP3 et jouez avec détection BPM auto, 4 difficultés, notes longues et fever mode !',
                'games.play': 'JOUER',
                'footer.copyright': '© 2025 João. Tous droits réservés. Fait avec',
                'footer.made': 'et Bootstrap.'
            },
            en: {
                'nav.brand': 'João',
                'nav.home': 'Home',
                'nav.about': 'About',
                'nav.projects': 'Projects',
                'nav.games': 'Games',
                'nav.tools': 'Tools',
                'nav.contact': 'Contact',
                'games.title': 'GAME ROOM',
                'games.description': 'DISCOVER MY COLLECTION OF RETRO GAMES CREATED IN JAVASCRIPT',
                'games.breakout.name': '🧱 BREAKOUT',
                'games.breakout.description': 'Break all bricks with power-ups, visual effects and 8 generated music tracks.',
                'games.pong.name': '🏓 PONG',
                'games.pong.description': 'Cyberpunk table tennis with adaptive AI, neon effects and 6 electronic ambient tracks.',
                'games.hexagon.name': '⬢ SUPER HEXAGON',
                'games.hexagon.description': 'Extreme reflex game with 4 difficulty levels, world rotation and Super Hexagon music.',
                'games.rhythm.name': '🎵 RHYTHM HERO',
                'games.rhythm.description': 'Analyze your MP3s and play with auto BPM detection, 4 difficulties, long notes and fever mode!',
                'games.play': 'PLAY',
                'footer.copyright': '© 2025 João. All rights reserved. Made with',
                'footer.made': 'and Bootstrap.'
            },
            pt: {
                'nav.brand': 'João',
                'nav.home': 'Início',
                'nav.about': 'Sobre',
                'nav.projects': 'Projetos',
                'nav.games': 'Jogos',
                'nav.tools': 'Ferramentas',
                'nav.contact': 'Contato',
                'games.title': 'SALA DE JOGOS',
                'games.description': 'DESCUBRA MINHA COLEÇÃO DE JOGOS RETRÔ CRIADOS EM JAVASCRIPT',
                'games.breakout.name': '🧱 BREAKOUT',
                'games.breakout.description': 'Quebre todos os tijolos com power-ups, efeitos visuais e 8 faixas musicais geradas.',
                'games.pong.name': '🏓 PONG',
                'games.pong.description': 'Tênis de mesa cyberpunk com IA adaptativa, efeitos neon e 6 faixas eletrônicas ambientes.',
                'games.hexagon.name': '⬢ SUPER HEXÁGONO',
                'games.hexagon.description': 'Jogo de reflexos extremo com 4 níveis de dificuldade, rotação do mundo e música Super Hexagon.',
                'games.rhythm.name': '🎵 RHYTHM HERO',
                'games.rhythm.description': 'Analise seus MP3s e jogue com detecção automática de BPM, 4 dificuldades, notas longas e fever mode!',
                'games.play': 'JOGAR',
                'footer.copyright': '© 2025 João. Todos os direitos reservados. Feito com',
                'footer.made': 'e Bootstrap.'
            }
        };

        // Apply translations based on saved language
        function applyTranslations(lang) {
            document.querySelectorAll('[data-translate]').forEach(element => {
                const key = element.getAttribute('data-translate');
                if (translations[lang] && translations[lang][key]) {
                    if (key.includes('footer.copyright')) {
                        // Preserve the heart icon
                        element.innerHTML = translations[lang][key] + ' <i class="bi bi-heart-fill text-danger"></i> ' + translations[lang]['footer.made'];
                    } else {
                        element.innerHTML = translations[lang][key];
                    }
                }
            });
        }

        // Change language
        function changeLanguage(lang) {
            localStorage.setItem('language', lang);
            applyTranslations(lang);
        }

        // Initialize with saved language or default to French
        document.addEventListener('DOMContentLoaded', function() {
            const savedLang = localStorage.getItem('language') || 'fr';
            const savedTheme = localStorage.getItem('preferred-theme') || 'light';
            
            if (savedTheme === 'dark') {
                toggleTheme();
            }
            
            applyTranslations(savedLang);
            
            // Initialize game previews
            initGamePreviews();
        });

        // Game preview animations
        function initGamePreviews() {
            // Breakout Preview
            const breakoutCanvas = document.getElementById('breakoutPreview');
            if (breakoutCanvas) {
                const breakoutCtx = breakoutCanvas.getContext('2d');
                breakoutCanvas.width = 400;
                breakoutCanvas.height = 225;
                
                let ballX = 200, ballY = 180, ballVelX = 3, ballVelY = -3;
                let paddleX = 175;
                let bricks = [];
                
                // Initialize bricks
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 10; col++) {
                        if (Math.random() > 0.3) {
                            bricks.push({
                                x: col * 40,
                                y: row * 20 + 20,
                                width: 38,
                                height: 18,
                                color: `hsl(${row * 60}, 70%, 50%)`
                            });
                        }
                    }
                }
                
                function drawBreakout() {
                    // Fond cyberpunk avec dégradé radial
                    const bgGradient = breakoutCtx.createRadialGradient(200, 112, 0, 200, 112, 250);
                    bgGradient.addColorStop(0, '#001122');
                    bgGradient.addColorStop(0.5, '#000033');
                    bgGradient.addColorStop(1, '#000011');
                    breakoutCtx.fillStyle = bgGradient;
                    breakoutCtx.fillRect(0, 0, 400, 225);
                    
                    // Grille cyberpunk en arrière-plan
                    breakoutCtx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                    breakoutCtx.lineWidth = 1;
                    for (let i = 0; i < 400; i += 20) {
                        breakoutCtx.beginPath();
                        breakoutCtx.moveTo(i, 0);
                        breakoutCtx.lineTo(i, 225);
                        breakoutCtx.stroke();
                    }
                    for (let i = 0; i < 225; i += 20) {
                        breakoutCtx.beginPath();
                        breakoutCtx.moveTo(0, i);
                        breakoutCtx.lineTo(400, i);
                        breakoutCtx.stroke();
                    }
                    
                    // Bricks avec effet néon et 3D
                    bricks.forEach((brick, index) => {
                        const time = Date.now() * 0.001;
                        const pulse = Math.sin(time * 3 + index * 0.5) * 0.3 + 0.7;
                        
                        // Couleur néon basée sur la ligne
                        const colors = ['#ff0080', '#00ff80', '#8000ff', '#ff8000', '#0080ff'];
                        const colorIndex = Math.floor(brick.y / 20) % colors.length;
                        
                        // Ombre 3D
                        breakoutCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        breakoutCtx.fillRect(brick.x + 2, brick.y + 2, brick.width, brick.height);
                        
                        // Brick principal avec dégradé
                        const brickGradient = breakoutCtx.createLinearGradient(brick.x, brick.y, brick.x + brick.width, brick.y + brick.height);
                        brickGradient.addColorStop(0, colors[colorIndex]);
                        brickGradient.addColorStop(1, colors[colorIndex] + '66');
                        breakoutCtx.fillStyle = brickGradient;
                        breakoutCtx.fillRect(brick.x, brick.y, brick.width, brick.height);
                        
                        // Effet néon (glow)
                        breakoutCtx.shadowColor = colors[colorIndex];
                        breakoutCtx.shadowBlur = 5 * pulse;
                        breakoutCtx.fillRect(brick.x, brick.y, brick.width, brick.height);
                        breakoutCtx.shadowBlur = 0;
                        
                        // Bordure brillante
                        breakoutCtx.strokeStyle = '#ffffff88';
                        breakoutCtx.lineWidth = 1;
                        breakoutCtx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                    });
                    
                    // Paddle avec effet holographique
                    const paddleGradient = breakoutCtx.createLinearGradient(paddleX, 200, paddleX + 50, 210);
                    paddleGradient.addColorStop(0, '#00ffff');
                    paddleGradient.addColorStop(0.5, '#ffffff');
                    paddleGradient.addColorStop(1, '#00ffff');
                    breakoutCtx.fillStyle = paddleGradient;
                    breakoutCtx.fillRect(paddleX, 200, 50, 10);
                    
                    // Effet glow sur la paddle
                    breakoutCtx.shadowColor = '#00ffff';
                    breakoutCtx.shadowBlur = 8;
                    breakoutCtx.fillRect(paddleX, 200, 50, 10);
                    breakoutCtx.shadowBlur = 0;
                    
                    // Ball avec trail et effet énergétique
                    const ballTime = Date.now() * 0.01;
                    
                    // Trail de la balle
                    for (let i = 0; i < 5; i++) {
                        const alpha = (5 - i) / 5 * 0.3;
                        const trailX = ballX - ballVelX * i * 2;
                        const trailY = ballY - ballVelY * i * 2;
                        
                        breakoutCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        breakoutCtx.beginPath();
                        breakoutCtx.arc(trailX, trailY, 5 - i, 0, Math.PI * 2);
                        breakoutCtx.fill();
                    }
                    
                    // Balle principale avec effet énergétique
                    const ballGradient = breakoutCtx.createRadialGradient(ballX, ballY, 0, ballX, ballY, 8);
                    ballGradient.addColorStop(0, '#ffffff');
                    ballGradient.addColorStop(0.7, '#ffff00');
                    ballGradient.addColorStop(1, '#ff8800');
                    breakoutCtx.fillStyle = ballGradient;
                    
                    // Pulsation énergétique
                    const pulseSize = 5 + Math.sin(ballTime) * 2;
                    breakoutCtx.shadowColor = '#ffff00';
                    breakoutCtx.shadowBlur = 10;
                    breakoutCtx.beginPath();
                    breakoutCtx.arc(ballX, ballY, pulseSize, 0, Math.PI * 2);
                    breakoutCtx.fill();
                    breakoutCtx.shadowBlur = 0;
                    
                    // Particules d'énergie autour de la balle
                    for (let i = 0; i < 3; i++) {
                        const angle = ballTime + i * Math.PI * 2 / 3;
                        const radius = 10 + Math.sin(ballTime * 2) * 3;
                        const px = ballX + Math.cos(angle) * radius;
                        const py = ballY + Math.sin(angle) * radius;
                        
                        breakoutCtx.fillStyle = `rgba(255, 255, 0, ${0.6 + Math.sin(ballTime * 3) * 0.3})`;
                        breakoutCtx.fillRect(px - 1, py - 1, 2, 2);
                    }
                    
                    // Update ball physics
                    ballX += ballVelX;
                    ballY += ballVelY;
                    
                    if (ballX <= 5 || ballX >= 395) ballVelX = -ballVelX;
                    if (ballY <= 5) ballVelY = -ballVelY;
                    if (ballY >= 195 && ballX > paddleX && ballX < paddleX + 50) ballVelY = -ballVelY;
                    
                    if (ballY > 225) {
                        ballX = 200;
                        ballY = 180;
                        ballVelY = -3;
                    }
                    
                    // Brick collision avec effet d'explosion
                    bricks = bricks.filter(brick => {
                        if (ballX > brick.x && ballX < brick.x + brick.width &&
                            ballY > brick.y && ballY < brick.y + brick.height) {
                            ballVelY = -ballVelY;
                            
                            // Effet d'explosion
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => {
                                    breakoutCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                                    breakoutCtx.beginPath();
                                    breakoutCtx.arc(brick.x + brick.width/2, brick.y + brick.height/2, i * 5, 0, Math.PI * 2);
                                    breakoutCtx.fill();
                                }, i * 50);
                            }
                            
                            return false;
                        }
                        return true;
                    });
                    
                    // Move paddle avec effet de vague
                    paddleX += Math.sin(Date.now() * 0.003) * 2;
                    paddleX = Math.max(0, Math.min(350, paddleX));
                }
                
                setInterval(drawBreakout, 16);
            }

            // Pong Preview
            const pongCanvas = document.getElementById('pongPreview');
            if (pongCanvas) {
                const pongCtx = pongCanvas.getContext('2d');
                pongCanvas.width = 400;
                pongCanvas.height = 225;
                
                let ballX = 200, ballY = 112;
                let ballVelX = 2, ballVelY = 1.5;
                let paddle1Y = 90, paddle2Y = 90;
                let glowIntensity = 0;
                
                function drawPong() {
                    // Fond cyberpunk
                    const gradient = pongCtx.createRadialGradient(200, 112, 0, 200, 112, 200);
                    gradient.addColorStop(0, '#0a0a0f');
                    gradient.addColorStop(0.7, '#000033');
                    gradient.addColorStop(1, '#000000');
                    pongCtx.fillStyle = gradient;
                    pongCtx.fillRect(0, 0, 400, 225);
                    
                    // Lignes de grille cyberpunk
                    pongCtx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                    pongCtx.lineWidth = 1;
                    for (let i = 0; i < 400; i += 40) {
                        pongCtx.beginPath();
                        pongCtx.moveTo(i, 0);
                        pongCtx.lineTo(i, 225);
                        pongCtx.stroke();
                    }
                    for (let i = 0; i < 225; i += 30) {
                        pongCtx.beginPath();
                        pongCtx.moveTo(0, i);
                        pongCtx.lineTo(400, i);
                        pongCtx.stroke();
                    }
                    
                    // Ligne centrale avec effet néon
                    pongCtx.strokeStyle = '#00ffff';
                    pongCtx.lineWidth = 2;
                    pongCtx.setLineDash([10, 10]);
                    pongCtx.beginPath();
                    pongCtx.moveTo(200, 0);
                    pongCtx.lineTo(200, 225);
                    pongCtx.stroke();
                    pongCtx.setLineDash([]);
                    
                    // Ombre néon pour la ligne centrale
                    pongCtx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                    pongCtx.lineWidth = 6;
                    pongCtx.setLineDash([10, 10]);
                    pongCtx.beginPath();
                    pongCtx.moveTo(200, 0);
                    pongCtx.lineTo(200, 225);
                    pongCtx.stroke();
                    pongCtx.setLineDash([]);
                    
                    // Paddle gauche avec effet néon
                    pongCtx.fillStyle = '#ff6600';
                    pongCtx.fillRect(20, paddle1Y, 8, 45);
                    pongCtx.shadowColor = '#ff6600';
                    pongCtx.shadowBlur = 10;
                    pongCtx.fillRect(20, paddle1Y, 8, 45);
                    pongCtx.shadowBlur = 0;
                    
                    // Paddle droite avec effet néon
                    pongCtx.fillStyle = '#9933ff';
                    pongCtx.fillRect(372, paddle2Y, 8, 45);
                    pongCtx.shadowColor = '#9933ff';
                    pongCtx.shadowBlur = 10;
                    pongCtx.fillRect(372, paddle2Y, 8, 45);
                    pongCtx.shadowBlur = 0;
                    
                    // Balle avec trail néon
                    glowIntensity = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
                    
                    // Trail de la balle
                    for (let i = 1; i <= 5; i++) {
                        const trailX = ballX - ballVelX * i * 2;
                        const trailY = ballY - ballVelY * i * 2;
                        const opacity = (6 - i) / 6 * 0.3;
                        
                        pongCtx.fillStyle = `rgba(255, 255, 0, ${opacity})`;
                        pongCtx.fillRect(trailX - 4, trailY - 4, 8, 8);
                    }
                    
                    // Balle principale
                    pongCtx.fillStyle = '#ffff00';
                    pongCtx.fillRect(ballX - 6, ballY - 6, 12, 12);
                    
                    // Effet de lueur sur la balle
                    const ballGlow = pongCtx.createRadialGradient(ballX, ballY, 0, ballX, ballY, 15);
                    ballGlow.addColorStop(0, `rgba(255, 255, 0, ${0.6 + glowIntensity * 0.4})`);
                    ballGlow.addColorStop(1, 'rgba(255, 255, 0, 0)');
                    pongCtx.fillStyle = ballGlow;
                    pongCtx.fillRect(ballX - 15, ballY - 15, 30, 30);
                    
                    // Animation
                    ballX += ballVelX;
                    ballY += ballVelY;
                    
                    // Rebonds sur les murs
                    if (ballY <= 6 || ballY >= 219) ballVelY = -ballVelY;
                    if (ballX <= 0 || ballX >= 400) {
                        ballVelX = -ballVelX;
                        ballX = 200;
                        ballY = 112;
                    }
                    
                    // IA simple pour les paddles
                    paddle1Y += (ballY - paddle1Y - 22.5) * 0.03;
                    paddle2Y += (ballY - paddle2Y - 22.5) * 0.025;
                    
                    // Limites des paddles
                    paddle1Y = Math.max(0, Math.min(180, paddle1Y));
                    paddle2Y = Math.max(0, Math.min(180, paddle2Y));
                }
                
                setInterval(drawPong, 16);
            }

            // Hexagon Preview - Reproduction PARFAITE de Super Hexagon
            const hexagonCanvas = document.getElementById('hexagonPreview');
            if (hexagonCanvas) {
                const hexagonCtx = hexagonCanvas.getContext('2d');
                hexagonCanvas.width = 400;
                hexagonCanvas.height = 225;
                
                // Configuration fidèle au vrai jeu
                const CENTER_X = 200;
                const CENTER_Y = 112;
                const HEX_RADIUS = 30; // Hexagone central plus visible
                const PLAYER_RADIUS = HEX_RADIUS + 12; // Joueur très proche du centre
                
                let gameTime = 0;
                let worldRotation = 0;
                let colorShift = 0;
                let spawnTimer = 0;
                
                // Player avec mouvement fluide et positions discrètes
                let player = {
                    position: 0, // Position discrète (0-5)
                    targetPosition: 0,
                    angle: 0,
                    moveSpeed: 0.12,
                    size: 5
                };
                
                let walls = [];
                let particles = [];
                
                // Patterns EXACTEMENT comme Super Hexagon
                const wallPatterns = [
                    [1, 1, 1, 1, 0, 1], // Une ouverture
                    [1, 1, 0, 1, 1, 1], // Une ouverture décalée
                    [0, 1, 1, 1, 1, 1], // Une ouverture au début
                    [1, 0, 1, 1, 1, 1], // Une ouverture décalée
                    [1, 1, 0, 0, 1, 1], // Deux ouvertures consécutives
                    [0, 1, 1, 0, 1, 1], // Deux ouvertures séparées
                    [1, 0, 1, 0, 1, 1], // Motif alternant
                    [0, 0, 1, 1, 1, 1], // Deux ouvertures au début
                    [1, 0, 1, 0, 1, 0], // Alterné parfait
                    [0, 1, 0, 1, 1, 1]  // Complexe
                ];
                
                // Couleurs dynamiques comme l'original
                const hexagonColors = ['#00ffff', '#ff4444', '#ffff00', '#ff00ff', '#00ff00'];
                
                function spawnWallPattern() {
                    const pattern = wallPatterns[Math.floor(Math.random() * wallPatterns.length)];
                    const spawnDistance = 150;
                    
                    for (let segment = 0; segment < 6; segment++) {
                        if (pattern[segment] === 1) { // 1 = mur bloqué
                            walls.push({
                                segment: segment,
                                distance: spawnDistance,
                                width: 20, // Épaisseur du mur
                                speed: 1.5, // Vitesse vers le centre
                                color: hexagonColors[Math.floor(Math.random() * hexagonColors.length)]
                            });
                        }
                    }
                }
                
                function updatePlayer() {
                    // Mouvement automatique fluide pour la démo
                    if (Math.random() < 0.015) { // Change direction parfois
                        const direction = Math.random() > 0.5 ? 1 : -1;
                        player.targetPosition = (player.targetPosition + direction + 6) % 6;
                    }
                    
                    // Interpolation fluide vers la position cible
                    let diff = player.targetPosition - player.position;
                    
                    // Ajuster pour le chemin le plus court autour du cercle
                    if (diff > 3) diff -= 6;
                    if (diff < -3) diff += 6;
                    
                    player.position += diff * player.moveSpeed;
                    
                    // Normaliser la position
                    if (player.position < 0) player.position += 6;
                    if (player.position >= 6) player.position -= 6;
                    
                    // Calculer l'angle pour le rendu
                    player.angle = (player.position * Math.PI) / 3;
                }
                
                function updateWalls() {
                    for (let i = walls.length - 1; i >= 0; i--) {
                        const wall = walls[i];
                        wall.distance -= wall.speed;
                        
                        // Supprimer les murs qui atteignent le centre
                        if (wall.distance <= HEX_RADIUS) {
                            walls.splice(i, 1);
                        }
                    }
                    
                    // Spawn périodique de nouveaux patterns
                    spawnTimer++;
                    if (spawnTimer >= 120) { // Tous les 2 secondes
                        spawnTimer = 0;
                        spawnWallPattern();
                    }
                }
                
                function drawBackground() {
                    // Background hypnotique avec dégradé radial rotatif
                    const bgGradient = hexagonCtx.createRadialGradient(CENTER_X, CENTER_Y, 0, CENTER_X, CENTER_Y, 200);
                    const hue1 = (colorShift * 0.7) % 360;
                    const hue2 = (colorShift * 0.3 + 120) % 360;
                    
                    bgGradient.addColorStop(0, `hsl(${hue1}, 40%, 8%)`);
                    bgGradient.addColorStop(0.5, `hsl(${hue2}, 50%, 4%)`);
                    bgGradient.addColorStop(1, '#000012');
                    
                    hexagonCtx.fillStyle = bgGradient;
                    hexagonCtx.fillRect(0, 0, 400, 225);
                    
                    // Effet de lignes rayonnantes tournantes
                    hexagonCtx.save();
                    hexagonCtx.translate(CENTER_X, CENTER_Y);
                    hexagonCtx.rotate(worldRotation * 0.3);
                    
                    for (let i = 0; i < 12; i++) {
                        const angle = (i * Math.PI) / 6;
                        const alpha = 0.03 + Math.sin(gameTime * 0.1 + i) * 0.02;
                        
                        hexagonCtx.strokeStyle = `hsla(${(colorShift + i * 30) % 360}, 60%, 50%, ${alpha})`;
                        hexagonCtx.lineWidth = 1;
                        hexagonCtx.beginPath();
                        hexagonCtx.moveTo(0, 0);
                        hexagonCtx.lineTo(Math.cos(angle) * 300, Math.sin(angle) * 300);
                        hexagonCtx.stroke();
                    }
                    
                    hexagonCtx.restore();
                }
                
                function drawHexagonalWalls() {
                    hexagonCtx.save();
                    hexagonCtx.translate(CENTER_X, CENTER_Y);
                    hexagonCtx.rotate(worldRotation);
                    
                    walls.forEach(wall => {
                        const segmentAngle = (wall.segment * Math.PI) / 3;
                        const angleStart = segmentAngle - Math.PI / 6;
                        const angleEnd = segmentAngle + Math.PI / 6;
                        
                        // Points du segment hexagonal externe
                        const outerStart = {
                            x: Math.cos(angleStart) * wall.distance,
                            y: Math.sin(angleStart) * wall.distance
                        };
                        const outerEnd = {
                            x: Math.cos(angleEnd) * wall.distance,
                            y: Math.sin(angleEnd) * wall.distance
                        };
                        
                        // Points du segment hexagonal interne
                        const innerDistance = wall.distance - wall.width;
                        const innerStart = {
                            x: Math.cos(angleStart) * innerDistance,
                            y: Math.sin(angleStart) * innerDistance
                        };
                        const innerEnd = {
                            x: Math.cos(angleEnd) * innerDistance,
                            y: Math.sin(angleEnd) * innerDistance
                        };
                        
                        // Dessiner le mur trapézoïdal
                        hexagonCtx.fillStyle = wall.color;
                        hexagonCtx.shadowColor = wall.color;
                        hexagonCtx.shadowBlur = 8;
                        
                        hexagonCtx.beginPath();
                        hexagonCtx.moveTo(outerStart.x, outerStart.y);
                        hexagonCtx.lineTo(outerEnd.x, outerEnd.y);
                        hexagonCtx.lineTo(innerEnd.x, innerEnd.y);
                        hexagonCtx.lineTo(innerStart.x, innerStart.y);
                        hexagonCtx.closePath();
                        hexagonCtx.fill();
                        
                        hexagonCtx.shadowBlur = 0;
                    });
                    
                    hexagonCtx.restore();
                }
                
                function drawCentralHexagon() {
                    hexagonCtx.save();
                    hexagonCtx.translate(CENTER_X, CENTER_Y);
                    hexagonCtx.rotate(worldRotation);
                    
                    // Pulsation hypnotique
                    const pulse = 1 + Math.sin(gameTime * 0.15) * 0.15;
                    const currentRadius = HEX_RADIUS * pulse;
                    const mainHue = (colorShift * 1.5) % 360;
                    
                    // Hexagone central lumineux
                    hexagonCtx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI) / 3;
                        const x = Math.cos(angle) * currentRadius;
                        const y = Math.sin(angle) * currentRadius;
                        if (i === 0) hexagonCtx.moveTo(x, y);
                        else hexagonCtx.lineTo(x, y);
                    }
                    hexagonCtx.closePath();
                    
                    hexagonCtx.strokeStyle = `hsl(${mainHue}, 100%, 85%)`;
                    hexagonCtx.lineWidth = 4;
                    hexagonCtx.shadowColor = `hsl(${mainHue}, 100%, 85%)`;
                    hexagonCtx.shadowBlur = 20;
                    hexagonCtx.stroke();
                    hexagonCtx.shadowBlur = 0;
                    
                    // Anneaux concentriques pour l'effet tunnel
                    for (let ring = 1; ring <= 3; ring++) {
                        const ringRadius = currentRadius + ring * 25;
                        const ringHue = (mainHue + ring * 80) % 360;
                        const alpha = 0.4 - ring * 0.1;
                        
                        hexagonCtx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            const x = Math.cos(angle) * ringRadius;
                            const y = Math.sin(angle) * ringRadius;
                            if (i === 0) hexagonCtx.moveTo(x, y);
                            else hexagonCtx.lineTo(x, y);
                        }
                        hexagonCtx.closePath();
                        
                        hexagonCtx.strokeStyle = `hsla(${ringHue}, 80%, 60%, ${alpha})`;
                        hexagonCtx.lineWidth = 2;
                        hexagonCtx.stroke();
                    }
                    
                    hexagonCtx.restore();
                }
                
                function drawPlayer() {
                    hexagonCtx.save();
                    hexagonCtx.translate(CENTER_X, CENTER_Y);
                    hexagonCtx.rotate(worldRotation);
                    
                    // Position du joueur autour de l'hexagone
                    const playerX = Math.cos(player.angle) * PLAYER_RADIUS;
                    const playerY = Math.sin(player.angle) * PLAYER_RADIUS;
                    
                    hexagonCtx.save();
                    hexagonCtx.translate(playerX, playerY);
                    hexagonCtx.rotate(player.angle + Math.PI / 2); // Orienter vers le centre
                    
                    // Triangle blanc lumineux
                    hexagonCtx.fillStyle = '#ffffff';
                    hexagonCtx.shadowColor = '#ffffff';
                    hexagonCtx.shadowBlur = 15;
                    
                    hexagonCtx.beginPath();
                    hexagonCtx.moveTo(0, -player.size);
                    hexagonCtx.lineTo(-player.size * 0.7, player.size);
                    hexagonCtx.lineTo(player.size * 0.7, player.size);
                    hexagonCtx.closePath();
                    hexagonCtx.fill();
                    
                    hexagonCtx.shadowBlur = 0;
                    hexagonCtx.restore();
                    hexagonCtx.restore();
                }
                
                function gameLoop() {
                    gameTime += 1;
                    worldRotation += 0.018; // Rotation constante et hypnotique
                    colorShift += 1.2;
                    
                    updatePlayer();
                    updateWalls();
                    
                    // Rendu
                    drawBackground();
                    drawHexagonalWalls();
                    drawCentralHexagon();
                    drawPlayer();
                }
                
                // Spawn initial de patterns
                spawnWallPattern();
                setTimeout(() => spawnWallPattern(), 1000);
                
                setInterval(gameLoop, 16); // 60 FPS
            }

            // Rhythm Preview - Simulation du vrai jeu avec notes qui tombent et lanes
            const rhythmCanvas = document.getElementById('rhythmPreview');
            if (rhythmCanvas) {
                const rhythmCtx = rhythmCanvas.getContext('2d');
                rhythmCanvas.width = 400;
                rhythmCanvas.height = 225;
                
                let notes = [];
                let time = 0;
                let beatTime = 0;
                let lanes = [{ active: false }, { active: false }, { active: false }, { active: false }];
                let hitEffects = [];
                let feverMode = false;
                let feverTime = 0;
                
                const laneColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4']; // F, G, J, K
                const laneWidth = 80;
                const hitZoneY = 180;
                
                // Generate realistic falling notes
                function spawnNote() {
                    if (Math.random() < 0.3) { // 30% chance per frame
                        const lane = Math.floor(Math.random() * 4);
                        const isLongNote = Math.random() < 0.2; // 20% chance for long notes
                        
                        notes.push({
                            lane: lane,
                            x: 60 + lane * laneWidth,
                            y: -20,
                            speed: 3,
                            color: laneColors[lane],
                            isLong: isLongNote,
                            length: isLongNote ? 40 + Math.random() * 60 : 0,
                            hit: false,
                            spawned: true
                        });
                    }
                }
                
                function addHitEffect(x, y, color) {
                    hitEffects.push({
                        x: x, y: y,
                        particles: Array.from({length: 8}, () => ({
                            dx: (Math.random() - 0.5) * 8,
                            dy: (Math.random() - 0.5) * 8 - 2,
                            life: 20,
                            size: Math.random() * 4 + 2
                        })),
                        color: color,
                        time: 0
                    });
                }
                
                function drawRhythm() {
                    time += 1;
                    beatTime += 0.1;
                    
                    // Dynamic background with beat reaction
                    const beatPulse = Math.sin(beatTime * 2) * 0.3 + 0.7;
                    const bgGradient = rhythmCtx.createLinearGradient(0, 0, 0, 225);
                    
                    if (feverMode) {
                        bgGradient.addColorStop(0, `rgba(50, 0, 50, ${beatPulse})`);
                        bgGradient.addColorStop(0.5, `rgba(80, 0, 40, ${beatPulse * 0.8})`);
                        bgGradient.addColorStop(1, '#000000');
                        feverTime--;
                        if (feverTime <= 0) feverMode = false;
                    } else {
                        bgGradient.addColorStop(0, `rgba(10, 10, 15, ${beatPulse})`);
                        bgGradient.addColorStop(0.5, `rgba(5, 15, 25, ${beatPulse * 0.8})`);
                        bgGradient.addColorStop(1, '#000000');
                    }
                    
                    rhythmCtx.fillStyle = bgGradient;
                    rhythmCtx.fillRect(0, 0, 400, 225);
                    
                    // Draw lanes with beat-reactive glow
                    for (let i = 0; i < 4; i++) {
                        const x = 60 + i * laneWidth;
                        const laneGlow = lanes[i].active ? 1 : 0.3;
                        
                        // Lane background
                        rhythmCtx.fillStyle = `rgba(${laneColors[i].slice(1, 3)}, ${laneColors[i].slice(3, 5)}, ${laneColors[i].slice(5, 7)}, 0.1)`;
                        rhythmCtx.fillRect(x - laneWidth/2, 0, laneWidth, 225);
                        
                        // Lane borders
                        rhythmCtx.strokeStyle = `${laneColors[i]}${Math.floor(laneGlow * 255).toString(16).padStart(2, '0')}`;
                        rhythmCtx.lineWidth = 2;
                        rhythmCtx.beginPath();
                        rhythmCtx.moveTo(x - laneWidth/2, 0);
                        rhythmCtx.lineTo(x - laneWidth/2, 225);
                        rhythmCtx.moveTo(x + laneWidth/2, 0);
                        rhythmCtx.lineTo(x + laneWidth/2, 225);
                        rhythmCtx.stroke();
                        
                        lanes[i].active = false;
                    }
                    
                    // Hit zone (where notes should be hit)
                    rhythmCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    rhythmCtx.fillRect(0, hitZoneY - 15, 400, 30);
                    
                    // Lane hit zones
                    for (let i = 0; i < 4; i++) {
                        const x = 60 + i * laneWidth;
                        rhythmCtx.strokeStyle = laneColors[i];
                        rhythmCtx.lineWidth = 3;
                        rhythmCtx.strokeRect(x - laneWidth/2 + 5, hitZoneY - 15, laneWidth - 10, 30);
                    }
                    
                    // Spawn notes periodically
                    if (time % 20 === 0) spawnNote();
                    
                    // Draw and update notes
                    notes.forEach((note, index) => {
                        note.y += note.speed;
                        
                        // Draw long note body
                        if (note.isLong) {
                            rhythmCtx.fillStyle = note.color + '88';
                            rhythmCtx.fillRect(note.x - 25, note.y, 50, note.length);
                            
                            // Long note borders
                            rhythmCtx.strokeStyle = note.color;
                            rhythmCtx.lineWidth = 2;
                            rhythmCtx.strokeRect(note.x - 25, note.y, 50, note.length);
                        }
                        
                        // Draw note head
                        rhythmCtx.fillStyle = note.color;
                        rhythmCtx.shadowColor = note.color;
                        rhythmCtx.shadowBlur = 10;
                        rhythmCtx.fillRect(note.x - 25, note.y - 10, 50, 20);
                        rhythmCtx.shadowBlur = 0;
                        
                        // Note glow effect
                        rhythmCtx.strokeStyle = '#ffffff';
                        rhythmCtx.lineWidth = 1;
                        rhythmCtx.strokeRect(note.x - 25, note.y - 10, 50, 20);
                        
                        // Auto-hit simulation near hit zone
                        if (!note.hit && note.y >= hitZoneY - 20 && note.y <= hitZoneY + 20) {
                            note.hit = true;
                            lanes[note.lane].active = true;
                            addHitEffect(note.x, hitZoneY, note.color);
                            
                            // Random fever mode activation
                            if (Math.random() < 0.1) {
                                feverMode = true;
                                feverTime = 100;
                            }
                        }
                        
                        // Remove notes that are off-screen
                        if (note.y > 250) {
                            notes.splice(index, 1);
                        }
                    });
                    
                    // Draw hit effects
                    hitEffects.forEach((effect, index) => {
                        effect.time++;
                        
                        effect.particles.forEach(particle => {
                            particle.x = effect.x + particle.dx * effect.time;
                            particle.y = effect.y + particle.dy * effect.time;
                            particle.life--;
                            
                            if (particle.life > 0) {
                                const alpha = particle.life / 20;
                                rhythmCtx.fillStyle = effect.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                                rhythmCtx.beginPath();
                                rhythmCtx.arc(particle.x, particle.y, particle.size * alpha, 0, Math.PI * 2);
                                rhythmCtx.fill();
                            }
                        });
                        
                        if (effect.time > 20) {
                            hitEffects.splice(index, 1);
                        }
                    });
                    
                    // Fever mode indicator
                    if (feverMode) {
                        rhythmCtx.fillStyle = '#ff6b6b';
                        rhythmCtx.font = 'bold 16px Arial';
                        rhythmCtx.fillText('FEVER MODE!', 150, 30);
                        
                        // Screen border glow
                        rhythmCtx.strokeStyle = '#ff6b6b';
                        rhythmCtx.lineWidth = 5;
                        rhythmCtx.strokeRect(2, 2, 396, 221);
                    }
                    
                    // Key indicators (F G J K)
                    const keys = ['F', 'G', 'J', 'K'];
                    for (let i = 0; i < 4; i++) {
                        const x = 60 + i * laneWidth;
                        const alpha = lanes[i].active ? 1 : 0.5;
                        
                        rhythmCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        rhythmCtx.font = 'bold 20px Arial';
                        rhythmCtx.textAlign = 'center';
                        rhythmCtx.fillText(keys[i], x, 210);
                    }
                }
                
                setInterval(drawRhythm, 16);
            }
        }

        let currentTheme = 'light';

        // Theme switching
        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.getElementById('theme-icon');
            
            if (currentTheme === 'light') {
                body.setAttribute('data-theme', 'dark');
                themeIcon.className = 'bi bi-sun-fill';
                currentTheme = 'dark';
            } else {
                body.removeAttribute('data-theme');
                themeIcon.className = 'bi bi-moon-fill';
                currentTheme = 'light';
            }
            
            localStorage.setItem('preferred-theme', currentTheme);
        }

        // Change language
    </script>
</body>
</html>
